# `BS::thread_pool` 中文说明文档（非官方简要版）

> 本文档是对原作者 Barak Shoshany 的开源项目 [`bshoshany/thread-pool`](https://github.com/bshoshany/thread-pool) 的**中文简要说明**，方便中文读者快速理解并上手使用。本仓库的完整、权威文档仍以英文版 `README.md` 为准。

---

## 一、项目简介

`BS::thread_pool` 是一个 **C++17 / C++20 / C++23 的轻量级线程池库**，特点是：

- **单头文件（header-only）**：只需一个 `BS_thread_pool.hpp`，无需单独编译或安装库；
- **高性能**：复用固定数量的工作线程，避免频繁创建和销毁线程；
- **跨平台**：只依赖 C++ 标准库，可在支持 C++17 的主流编译器上使用（GCC / Clang / MSVC）；
- **易使用**：接口设计简单直观，文档示例丰富，适合学习、课程项目和工程实践。

你可以把它理解为：**一个用起来很顺手的 `std::thread` 升级版封装**，专门用来管理大量并发任务。

---

## 二、适用场景

适合在以下场景中使用：

- 需要执行**大量、独立的小任务**：如图像处理、数值计算、数据预处理；
- 对性能敏感，希望充分利用多核 CPU；
- 想在课程作业 / 毕设中展示自己对**多线程与线程池原理**的理解；
- 不想自己从零写一套复杂的线程管理逻辑，希望在此基础上进行裁剪和扩展。

---

## 三、主要特性概览

以下是从英文 README 中提炼出来的核心特性：

1. **快速（Fast）**
   - 为高性能计算设计，支持大量 CPU 核心；
   - 通过任务队列 + 线程复用减少创建线程的开销；
   - 可选择性启用/关闭一些高级特性，在功能与开销之间权衡。

2. **轻量（Lightweight）**
   - 单头文件，结构紧凑；
   - 无第三方依赖，只依赖 C++ 标准库；
   - 代码行数很少（不含注释、空行等）却功能完整。

3. **现代（Modern）**
   - 支持 C++17/20/23，并利用新标准的语言/库特性；
   - 提供 C++20 **module** 版本：可以使用 `import BS.thread_pool;`；
   - 在 C++23 上支持 `import std;` 的标准库模块（在支持的平台上）。

4. **易用（Easy to use）**
   - 常见使用场景只需要少量成员函数：构造线程池、提交任务、等待任务完成；
   - 支持自动并行化循环（类似“并行 for”）；
   - 有大量示例和详尽文档，适合作为学习多线程的参考实现。

5. **附加功能**
   - 获取/修改线程数量；
   - 查询当前队列中任务数量、正在运行的任务数量；
   - 清空任务队列；
   - 线程初始化/清理函数；
   - 本地扩展：线程优先级、CPU 亲和性、线程名等（通过系统 API 实现）。

---

## 四、快速上手

### 1. 获取头文件

在本仓库中，你可以在 `include/` 目录下找到：

- `include/BS_thread_pool.hpp`

在自己的项目中，只需要保证编译器的 `include` 路径能找到该文件即可（例如把 `include/` 路径加入到编译参数）。

### 2. 最小示例

下面是一个最小可运行的示例，演示如何创建线程池并提交一个简单任务：

```cpp
#include "BS_thread_pool.hpp"
#include <iostream>

int main() {
    BS::thread_pool pool; // 默认使用硬件支持的最大线程数

    auto f = pool.submit_task([] { return 1 + 1; });
    std::cout << "结果: " << f.get() << '\n';

    return 0;
}
```

编译示例（请根据自己的编译环境调整）：

- **GCC / Clang（Linux / macOS / WSL）**：

  ```bash
  g++ -std=c++17 main.cpp -O2 -pthread -I./include -o main
  ./main
  ```

- **MSVC（Windows, Developer Command Prompt）**：

  ```bat
  cl /std:c++17 /O2 /I include main.cpp
  main.exe
  ```

> 注意：`-I include` 或 `/I include` 要根据你保存 `BS_thread_pool.hpp` 的实际路径来修改。

---

## 五、核心接口简要说明

这里只给出最常用的一些接口概念性说明，具体细节请查阅英文 `README.md` 或源码注释。

### 1. 线程池构造与大小

- `BS::thread_pool pool;`
  - 默认使用系统支持的最大并发线程数。
- 也可以显式指定线程数：
  - `BS::thread_pool pool(n);`
- 可以在运行过程中通过 `reset()` 修改线程数量。

### 2. 提交任务

- 带返回值 + `std::future`：
  - `auto fut = pool.submit_task(func, arg1, arg2, ...);`
  - 通过 `fut.get()` 获取结果或等待执行结束。

- 不需要返回值、追求性能：
  - `pool.detach_task(func, arg1, arg2, ...);`
  - 不会返回 `future`，适合“不需要结果，只要执行”的场景。

### 3. 并行化循环

- 通过 `submit_loop()` / `detach_loop()` 可以把一个 `for` 循环拆成多个任务并行执行：
  - 类似于：把区间 `[0, N)` 分成多段，每段作为一个任务提交给线程池。
  - 返回 `BS::multi_future`（对于 `submit_loop`），可以用来等待所有子任务。

### 4. 任务管理

- 查询任务数量：
  - `get_tasks_queued()`：队列中等待的任务数；
  - `get_tasks_running()`：当前正在执行的任务数；
  - `get_tasks_total()`：队列 + 运行中的总任务数。

- 清空队列：
  - `purge()`：丢弃尚未开始执行的任务。

---

## 六、线程池实现原理概览

如果你打算把这个项目作为 C++ 课程大作业的参考，实现**你自己的线程池**，理解原理非常重要。一个典型线程池通常包含以下几个核心组件：

1. **任务队列（Task Queue）**
   - 常用结构：`std::queue<std::function<void()>>` 或自定义任务结构；
   - 需要用 `std::mutex` 保护，保证多线程同时访问时不会竞争出错；
   - 任务被提交时，放入队列；空闲线程从队列中取任务执行。

2. **工作线程（Worker Threads）**
   - 在构造函数中创建若干个 `std::thread`，每个线程执行类似的循环：
     1. 加锁，等待任务队列非空（`std::condition_variable::wait`）；
     2. 取出一个任务并解锁；
     3. 执行任务；
     4. 回到步骤 1，直到线程池被关闭。

3. **同步与唤醒机制**
   - 使用 `std::condition_variable` 让空闲线程在没有任务时休眠；
   - 新任务到来时，通过 `notify_one()` 或 `notify_all()` 唤醒线程。

4. **任务返回值（`std::future`）**
   - 常见做法：使用 `std::packaged_task` 把任意可调用对象包装成一个返回 `future` 的任务；
   - 在线程池内部只需要存储一个不带返回值的 `std::function<void()>`；
   - 使用者拿到的 `future` 可以 `get()` 结果或捕获异常。

5. **安全停止（Stop / Join）**
   - 在线程池析构时：
     - 设置一个标志位 `stop = true`；
     - 唤醒所有工作线程；
     - 在主线程中 `join()` 所有工作线程，确保程序安全退出。

阅读 `include/BS_thread_pool.hpp` 源码时，可以带着上面这些点去对照，会更容易理解整体设计。

---

## 七、如果你用于 C++ 课程大作业的建议

如果你的课程要求是**“自己实现一个线程池”**，可以把这个项目当作一个高质量参考实现，但建议：

1. **不要直接复制完整源码**
   - 这既不利于你真正理解多线程原理，也可能违反课程的学术规范；

2. **从简到繁，先实现一个精简版，再逐步扩展**
   - 精简版可以只实现：
     - 固定线程数的线程池；
     - 提交任务（返回 `std::future`）；
     - 安全析构与等待所有任务；
   - 高级功能（任务优先级、动态扩容、并行循环、原生扩展等）可作为“加分项”按需选择。

3. **多在代码中写注释，解释你的设计决策**
   - 比如：为什么要用互斥锁、为什么要有条件变量、为什么要有 `stop` 标志位等；
   - 老师很看重“你是否真的理解自己写的代码”。

4. **可以用本项目的接口风格作为参考，但实现细节请自己写**
   - 比如你也可以叫 `thread_pool`，也可以提供 `submit` / `enqueue` 之类接口；
   - 内部的数据结构、错误处理、边界条件等，可以根据自己的理解来重新设计。

5. **建议的实现顺序**
   1. 先写一个最简单的线程池：
      - 一个任务队列 + 若干工作线程 + `enqueue()`；
   2. 增加 `std::future` 支持；
   3. 处理好析构/停止逻辑，避免死锁和未 `join` 的线程；
   4. 如果时间允许，再添加并行循环、任务优先级等进阶功能。

---

## 八、更多参考

- 英文完整文档：见本仓库中的 `README.md`（约 3000+ 行，非常详细）；
- 源码入口：`include/BS_thread_pool.hpp`；
- 自动化测试与示例：`tests/BS_thread_pool_test.cpp`；
- 编译与测试辅助脚本：`scripts/compile_cpp.py`、`scripts/test_all.py`。

---

## 九、原项目与版权信息

- 原作者：**Barak Shoshany**  
- GitHub：<https://github.com/bshoshany>  
- 项目地址：<https://github.com/bshoshany/thread-pool>  
- 许可证：**MIT License**（详见仓库中的 `LICENSE.txt`）。

本中文文档仅用于学习和理解之用，如需在自己的公开项目或论文中使用本库，请遵守原项目的许可证要求，并适当注明引用。
